<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>编译技术实验总结感想</title>
      <link href="/2025/01/10/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93%E6%84%9F%E6%83%B3/"/>
      <url>/2025/01/10/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93%E6%84%9F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="《编译技术》实验总结感想"><a href="#《编译技术》实验总结感想" class="headerlink" title="《编译技术》实验总结感想"></a>《编译技术》实验总结感想</h1><h2 id="1-实验总结"><a href="#1-实验总结" class="headerlink" title="1. 实验总结"></a>1. 实验总结</h2><p>这个学期的编译实验一共分为文法解读、词法分析、语法分析、语义分析、代码生成、代码优化几个部分。总体来说，难度依次递增。</p><p>我选择的编程语言是Java，这也是我最喜欢的一种语言。在实验开始前，我还在庆幸不用像上学期的OS一样整天跟C语言打交道，又能愉快地编写最喜欢的Java了。</p><p>在最初的词法分析和语法分析中，我还体验着迭代开发Java、欣赏自己的设计模式的乐趣中。虽然语法分析的工作量相比于词法分析陡增，但是我个人觉得我的类设计还是比较清晰的，因此写完之后也算是非常有成就感了。</p><p>之后的语义分析其实就是建立符号表并处理语义错误，因此比较简单。但完成这里的时候，我深感对于类设计等的欠缺，几乎把面向对象的语言写成了面向过程的语言。而后面的中端代码生成是在语义分析的基础上做的，因此我总体的设计在此后也变得不忍直视。</p><p>代码生成我选择的是LLVM IR+MIPS。此时能给予我帮助的只有指导书了，然而我觉得指导书并不全面，只提供了最基本的介绍，具体实现大部分都是我自己摸索出来的。比如在LLVM IR生成中，指导书并没有说符号表到底存什么东西，我最后想的是存地址对应的虚拟寄存器，如果存值的话，还需要考虑分支合并时的phi指令等，如果指导书直接说明phi指令建议在后面优化时实现，可能我会花更少的时间了。</p><p>在MIPS的生成时，也有类似情况。我一开始理解错了LLVM IR中”虚拟寄存器“的概念，以为虚拟寄存器就必须得分配一个物理寄存器，所以我直接将后面优化部分的寄存器分配在生成MIPS时就写了，这耗费了我大量的时间。而后来我几乎快完成的时候经同学的提醒，才意识到虚拟寄存器也就是一个变量而已了，完全可以全部放在栈上。</p><p>在代码生成的那段时间，特别是MIPS生成，是整个过程最难、耗费时间最长的、最觉得无助的。中间代码和目标代码生成都花费了我快2周时间。一开始我以为MIPS生成就是简单的逐条指令翻译，但是我直接将寄存器分配纳入，使得整个过程非常坎坷，各种bug、各种问题……那时真的是最想放弃的一瞬。</p><p>好在直接实现了寄存器分配，使我竞速排序的排名不算太靠后。同时由于耗费了太多时间，我也无力做工作量巨大的复杂优化了（比如LLVM IR mem2reg）。但是我本身也无意去卷竞速排名，我感觉我能做出MIPS并在排名里有一席之地就足够了。最后的最后，我尽我所能地实现了一些比较简单的优化，也算是给整个编译实验画上了一个圆满的句号吧。</p><h2 id="2-感想"><a href="#2-感想" class="headerlink" title="2. 感想"></a>2. 感想</h2><p>完成整个编译实验是我个人第一次独立完成工作量和复杂度这么庞大的项目了，最后看了一下总共有9216行代码。但肯定不是代码行数越多就越好，我在中后期里类和方法设计方面比较欠缺，代码的质量也不算太高。虽然每次作业都是”万事开头难“，但是每次点击IDEA的”新建类“按钮都满怀着期待，期待着这个类的设计能够足够完美，而足够完美的设计在方便使用的同时真的能给人自豪感；虽然每次编码、debug过程都非常艰辛，但是每次看到AC通过的赏心悦目的绿色时，会感觉一切都值了。</p><h2 id="3-一点建议"><a href="#3-一点建议" class="headerlink" title="3. 一点建议"></a>3. 一点建议</h2><p>希望指导书可以给一些总体的编码实现思路（但是太具体也不行，否则大家都写成一样的了），毕竟从无到有的开发如果没有参考还是很有难度的，而且容易走弯路。</p>]]></content>
      
      
      <categories>
          
          <category> 编译技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译技术开发文档</title>
      <link href="/2025/01/10/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/"/>
      <url>/2025/01/10/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>《编译技术》实验开发文档</p><p>Author：bush</p></blockquote><h1 id="1-参考编译器介绍"><a href="#1-参考编译器介绍" class="headerlink" title="1 参考编译器介绍"></a>1 参考编译器介绍</h1><p>主要参考了教材上PL&#x2F;0以及tolang</p><h2 id="1-1-总体结构"><a href="#1-1-总体结构" class="headerlink" title="1.1 总体结构"></a>1.1 总体结构</h2><p>PL&#x2F;0是一个编译-解释执行程序，总体结构分为两个部分：</p><ol><li>先把PL&#x2F;0编译成目标程序（P-code指令）</li><li>再对目标程序进行解释执行，得到运行结果</li></ol><h2 id="1-2-接口设计"><a href="#1-2-接口设计" class="headerlink" title="1.2 接口设计"></a>1.2 接口设计</h2><p>PL&#x2F;0编译程序采用一遍扫描，以语法分析为核心，由它调用词法分析程序取单词，在语法分析过程中同时进行语义分析处理，并生成目标指令。</p><p>如遇有语法、语义错误，则随时调用出错处理程序，打印出错信息。</p><h2 id="1-3-文件组织"><a href="#1-3-文件组织" class="headerlink" title="1.3 文件组织"></a>1.3 文件组织</h2><p>前端和后端分包等。</p><h1 id="2-编译器总体设计"><a href="#2-编译器总体设计" class="headerlink" title="2 编译器总体设计"></a>2 编译器总体设计</h1><h2 id="2-1-总体结构"><a href="#2-1-总体结构" class="headerlink" title="2.1 总体结构"></a>2.1 总体结构</h2><p>总体结构与PL&#x2F;0不同，是编译程序。</p><ol><li>先编译成LLVM IR</li><li>由LLVM IR生成MIPS汇编代码</li><li>直接运行MIPS汇编代码</li></ol><hr><p>编译器总体采用多遍扫描，即先通过一次完整的词法分析得到token序列，再进行语法分析得到语法树。</p><h2 id="2-2-接口设计"><a href="#2-2-接口设计" class="headerlink" title="2.2 接口设计"></a>2.2 接口设计</h2><h3 id="2-2-1-词法分析器Lexer"><a href="#2-2-1-词法分析器Lexer" class="headerlink" title="2.2.1 词法分析器Lexer"></a>2.2.1 词法分析器Lexer</h3><p><code>Lexer.java</code>主要提供一个接口<code>getToken()</code></p><ul><li><strong>调用形式</strong>：<code>token = lexer.getToken()</code></li><li><strong>作用</strong>：根据设置的读取器<code>BufferedReader</code>，每次调用返回下一个解析到的<code>Token</code>类符号</li><li><strong>备注</strong>：当且仅当读到文件流末尾时返回<code>null</code></li></ul><h3 id="2-2-2-语法分析器Parser"><a href="#2-2-2-语法分析器Parser" class="headerlink" title="2.2.2 语法分析器Parser"></a>2.2.2 语法分析器Parser</h3><p><code>Parser.java</code>主要提供一个接口<code>parse()</code></p><ul><li><strong>调用形式</strong>：<code>compUnit = parser.parse()</code></li><li><strong>作用</strong>：首先调用词法分析器的接口解析得到token序列，然后递归解析以一个<code>CompUnit</code>类实例表示的语法树</li></ul><h2 id="2-3-文件组织"><a href="#2-3-文件组织" class="headerlink" title="2.3 文件组织"></a>2.3 文件组织</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 主要文件结构如下</span><br><span class="line">├─error</span><br><span class="line">│  └─CompilerError.java</span><br><span class="line">├─frontend</span><br><span class="line">│  ├─lexer</span><br><span class="line">│  │   └─Lexer.java</span><br><span class="line">│  └─parser</span><br><span class="line">│      ├─declaration</span><br><span class="line">│      ├─expression</span><br><span class="line">│      ├─function</span><br><span class="line">│      ├─statement</span><br><span class="line">│      └─terminal</span><br><span class="line">│      └─Parser.java</span><br><span class="line">├─Compiler.java</span><br><span class="line">├─config.json</span><br><span class="line">└─README.md</span><br></pre></td></tr></table></figure><h1 id="3-词法分析设计"><a href="#3-词法分析设计" class="headerlink" title="3 词法分析设计"></a>3 词法分析设计</h1><h2 id="3-1-编码前的设计"><a href="#3-1-编码前的设计" class="headerlink" title="3.1 编码前的设计"></a>3.1 编码前的设计</h2><p>主要参考的是教材上的PL&#x2F;0，以及第三章的词法分析示例。</p><p><img src="/../assets/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20241014104848084.png" alt="image-20241014104848084"></p><p>代码大致流程图如上，编码时，主要依靠这张图，其他细节在编码时实现。</p><p><code>Compiler.java</code>这一主程序调用<code>frontedn/Lexer.java</code>中的<code>getSymbol</code>方法。在此次作业中主逻辑还未实现，因此可以在<code>Compiler.java</code>中暂时编写满足本次作业的测试逻辑。</p><h2 id="3-2-编码完成后的修改"><a href="#3-2-编码完成后的修改" class="headerlink" title="3.2 编码完成后的修改"></a>3.2 编码完成后的修改</h2><h3 id="3-2-1-设计模式的选择、类的设计"><a href="#3-2-1-设计模式的选择、类的设计" class="headerlink" title="3.2.1 设计模式的选择、类的设计"></a>3.2.1 设计模式的选择、类的设计</h3><ul><li>词法分析器<code>Lexer.java</code>采用单例模式（饿汉式）的设计模式，作为一个静态类存放到主类<code>Compiler.java</code>中，其方法也多是静态方法，最主要的是<code>getToken</code>方法；<br><img src="/../assets/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20241014104957471.png" alt="image-20241014104957471"></li><li>单词token作为一个类<code>Token</code>，类型作为其内部枚举类<code>TokenType</code>；</li><li>编译错误的处理：<code>CompilerError</code>是一个<code>Exception</code>的子类，在<code>Lexer</code>等各个组件的方法可以被抛出，在主类<code>Compiler</code>中被<code>try-catch</code>处理。</li></ul><h3 id="3-2-2-其他更改或BUG"><a href="#3-2-2-其他更改或BUG" class="headerlink" title="3.2.2 其他更改或BUG"></a>3.2.2 其他更改或BUG</h3><ol><li>最大的疏忽是忘记添加处理注释的代码了，应该把读入<code>/</code>符号后的逻辑单列出来。</li><li>另外，只考虑到字符常量中只有一个字符的情况了，没有考虑到转义字符</li></ol><h3 id="3-2-3-语法分析完成后的改动"><a href="#3-2-3-语法分析完成后的改动" class="headerlink" title="3.2.3 语法分析完成后的改动"></a>3.2.3 语法分析完成后的改动</h3><ul><li>最大的改动是，由设计之初的一遍扫描改为多遍扫描<ul><li>在词法分析时，设计采用一遍扫描，即语法分析中每次调用词法分析的接口<code>getToken()</code>即返回下一个token。<br>在词法分析程序内部中使用<code>BufferedReader</code>的<code>mark()</code>和<code>reset()</code>两个方法组实现字符读取的回退，在语法分析开始时计划在调用<code>getToken()</code>接口的外层也使用这两个方法实现token的回退和预读。</li><li>但是这样会使得在接口内部再次调用<code>mark()</code>覆盖外层的<code>mark()</code>使得无法回退token等问题，因此改为多遍扫描，即在语法分析前先完成整个程序的词法分析得到token序列，接下来的语法分析便不用通过操作读取器回退token，功能完成解耦。</li></ul></li><li>修改了词法分析解析多行注释的部分：在de完语法分析的bug后，公共测试库全过但测试点16RE，最后发现是词法分析中对多行注释的读取有误</li></ul><h1 id="4-语法分析设计"><a href="#4-语法分析设计" class="headerlink" title="4 语法分析设计"></a>4 语法分析设计</h1><h2 id="4-1-编码前的设计"><a href="#4-1-编码前的设计" class="headerlink" title="4.1 编码前的设计"></a>4.1 编码前的设计</h2><ul><li>与词法分析类似，使用单例模式实现<code>Parser.java</code></li><li>主要采用递归下降程序实现</li><li>此外通过预读解决多个规则匹配问题</li></ul><p>以下是编写递归程序时的辅助表格，部分非终结符的FIRST略</p><table><thead><tr><th>非终结符</th><th>FIRST集</th><th>完成</th></tr></thead><tbody><tr><td>CompUnit</td><td>CONSTTK, INTTK, CHARTK, VOIDTK</td><td>V</td></tr><tr><td>Decl</td><td>CONSTTK, INTTK, CHARTK</td><td>V</td></tr><tr><td>FuncDef</td><td>VOIDTK, INTTK, CHARTK</td><td>V</td></tr><tr><td>MainFuncDef</td><td>INTTK</td><td>V</td></tr><tr><td>ConstDecl</td><td>CONSTTK</td><td>V</td></tr><tr><td>VarDecl</td><td>INT, CHAR</td><td>V</td></tr><tr><td>FuncType</td><td>‘VOIDTK, INTTK, CHARTK</td><td>V</td></tr><tr><td>BType</td><td>INTTK, CHARTK</td><td>V</td></tr><tr><td>ConstDef</td><td></td><td>V</td></tr><tr><td>Ident</td><td>Vt</td><td>V</td></tr><tr><td>ConstInitVal</td><td></td><td>V</td></tr><tr><td>ConstExp</td><td></td><td>V</td></tr><tr><td>StringConst</td><td>Vt</td><td>V</td></tr><tr><td>AddExp</td><td></td><td>V</td></tr><tr><td>MulExp</td><td></td><td>V</td></tr><tr><td>UnaryExp</td><td>LPARENT, IDENFR, INTCON, CHRCON, PLUS, MINU, NOT</td><td>V</td></tr><tr><td>PrimaryExp</td><td>LPARENT, IDENFR, INTCON, CHRCON</td><td>V</td></tr><tr><td>FuncRParams</td><td></td><td>V</td></tr><tr><td>UnaryOp</td><td>PLUS, MINU, NOT</td><td>V</td></tr><tr><td>LVal</td><td>IDENFR</td><td>V</td></tr><tr><td>Number</td><td>INTCON</td><td>V</td></tr><tr><td>Character</td><td>CHRCON</td><td>V</td></tr><tr><td>IntConst</td><td>Vt</td><td>V</td></tr><tr><td>CharConst</td><td>Vt</td><td>V</td></tr><tr><td>VarDef</td><td></td><td>V</td></tr><tr><td>InitVal</td><td></td><td>V</td></tr><tr><td>Exp</td><td>LPARENT, IDENFR, INTCON, CHRCON, PLUS, MINU, NOT</td><td>V</td></tr><tr><td>FuncFParams</td><td>INTTK, CHARTK</td><td>V</td></tr><tr><td>FuncFParam</td><td>INTTK, CHARTK</td><td>V</td></tr><tr><td>Block</td><td>LPARENT</td><td>V</td></tr><tr><td>BlockItem</td><td></td><td>V</td></tr><tr><td>Stmt</td><td></td><td>V</td></tr><tr><td>ForStmt</td><td></td><td>V</td></tr><tr><td>Cond</td><td></td><td>V</td></tr><tr><td>LOrExp</td><td></td><td>V</td></tr><tr><td>LAndExp</td><td></td><td>V</td></tr><tr><td>EqExp</td><td></td><td>V</td></tr><tr><td>RelExp</td><td></td><td>V</td></tr></tbody></table><h2 id="4-2-编码后的设计"><a href="#4-2-编码后的设计" class="headerlink" title="4.2 编码后的设计"></a>4.2 编码后的设计</h2><h3 id="4-2-1-设计模式"><a href="#4-2-1-设计模式" class="headerlink" title="4.2.1 设计模式"></a>4.2.1 设计模式</h3><ul><li>语法分析器<code>Parser.java</code>与词法分析器类似，采用饿汉式单例模式；</li><li>单例模式的静态方法与非静态方法的实现效果类似，但为了简便，在语法成分类中要频繁调用的<code>getSymbol() currentSymbol()</code>等方法设置为静态方法。</li></ul><h3 id="4-2-2-递归下降读取逻辑"><a href="#4-2-2-递归下降读取逻辑" class="headerlink" title="4.2.2 递归下降读取逻辑"></a>4.2.2 递归下降读取逻辑</h3><ul><li>在一个程序要调用一个分析子程序前，需要使用<code>Parser.getSymbol()</code>读取一个token</li><li>在分析子程序里，分析子程序会递归匹配所有token，但并不会超前读取（例如分析子程序只匹配一个终结符即结束，则不会调用<code>Parser.getSymbol()</code>），因此一个子成分分析完后，<code>symbol</code>停留在最后匹配到的那个token处</li><li>接着继续使用<code>Parser.getSymbol()</code>读取一个token并调用剩下的分析子程序</li><li>在遇到终结符时，匹配后不需要使用<code>Parser.getSymbol()</code>，因为递归过程相当于在匹配之前已经执行一次</li></ul><h3 id="4-2-3-类设计"><a href="#4-2-3-类设计" class="headerlink" title="4.2.3 类设计"></a>4.2.3 类设计</h3><ul><li><p>对于语法树的构建，首先设计了一个语法树节点的接口<code>SyntaxNode.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SyntaxNode</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">parse</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">outputString</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于每个语法成分，均设计同名的一个类并实现以上接口；</p><ul><li>对于该语法成分的一条规则，规则右部语法成分作为该类的一个属性存储<ul><li>若有多条规则，则根据FIRST集的不同划分成不同的子类，超类属性类型为超类，但在<code>parse()</code>方法中根据当前符号选择实例化不同的子类（方法重写和多态）</li><li>若右部语法成分可重复多次，则存储对应的列表</li><li>若右部语法成分可选，则值非<code>null</code>时表示存在，否则不存在</li></ul></li><li>类的<code>parse()</code>方法会根据语法分析器当前解析到的符号<code>Parser.currentSymbol()</code>向前解析，并返回自身（<code>return this</code>）</li><li>顶层语法成分调用<code>parse()</code>方法解析时，为下层语法成分属性赋值一个调用过自身<code>parse()</code>方法的<code>new</code>对象，这样就实现了递归</li><li>每个语法成分的<code>outputString()</code>方法按照同样的递归逻辑返回需要输出的内容和格式</li></ul></li><li><p>为了使得结构清晰，按功能将语法成分包为<code>declaration</code>, <code>expression</code>, <code>function</code>, <code>statement</code>, <code>terminal</code>五个包</p></li><li><p>对于有多条规则的语法成分的子类也分包管理，如<code>stmts</code>, <code>unaryexps</code>, <code>primaryexps</code></p></li></ul><h3 id="4-2-4-FIRST集冲突解决方案"><a href="#4-2-4-FIRST集冲突解决方案" class="headerlink" title="4.2.4 FIRST集冲突解决方案"></a>4.2.4 FIRST集冲突解决方案</h3><ul><li>若FIRST集冲突，可以类似的查看规则的SECOND集，并使用<code>preReadNext()</code>预读一个token的方法区分（大部分可以解决）</li><li>仅在<code>CompUnit-&gt;Decl|FuncDef</code>，SECOND集仍冲突，则<code>preReadNextNext()</code>预读下下个token可以区分</li><li>仅在<code>Stmt</code>的推导时，使用SECOND集仍然难以区分，此处采用回溯token的方法解决<ul><li>在回溯时需要同时回溯抛出的错误！不然会出现多输出错误的情况</li></ul></li></ul><h3 id="4-2-5-左递归文法解决方案"><a href="#4-2-5-左递归文法解决方案" class="headerlink" title="4.2.5 左递归文法解决方案"></a>4.2.5 左递归文法解决方案</h3><ul><li><p>对于左递归文法，将规则改写为扩充的BNF范式。<br>以<code>MulExp → UnaryExp | MulExp (&#39;*&#39; | &#39;/&#39; | &#39;%&#39;) UnaryExp</code>这条规则为例，消除左递归后得到<br><code>MulExp → UnaryExp &#123; (&#39;*&#39; | &#39;/&#39; | &#39;%&#39;) UnaryExp &#125;</code></p></li><li><p>以这条规则为例，这些具有递归文法的类属性设置为一个<code>UnaryExp</code>类和一个元素为<code>OpUnaryExp</code>类的列表分别表示EBNF范式的两部分</p></li><li><p>其中<code>OpUnaryExp</code>为静态内部类，相当于一个二元组，包含每个重复的符号<code>op</code>和<code>unaryExp</code></p></li><li><p>至此便消除左递归文法，在分析方法中不会递归调用自己，而是不断调用下一层的语法成分分析方法；并且在输出方法<code>outputString()</code>中，也可以通过类似逻辑输出正确的语法树结构</p></li><li><p>从<code>UnaryExp-&gt;MulExp-&gt;AddExp-&gt;RelExp-&gt;EqExp-&gt;LAndExp-&gt;LorExp</code>各层次间关系是一模一样的，因此编写完<code>UnaryExp-&gt;MulExp</code>后，可通过代码查找替换迁移得到后面的层间关系；手稿如下：</p><p><img src="/../assets/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/07fae8c98c7d24c7990122f1fc798d0.jpg" alt="07fae8c98c7d24c7990122f1fc798d0"></p></li></ul><h3 id="4-2-6-关于错误处理的修改"><a href="#4-2-6-关于错误处理的修改" class="headerlink" title="4.2.6 关于错误处理的修改"></a>4.2.6 关于错误处理的修改</h3><ul><li><p>在之前的词法分析设计时，设计了一个自定义的<code>CompileError</code>并继承<code>Exception</code>类，错误通过throw抛出自<code>CompileError</code>报错并在上层处理，但在此次编码时发现：</p><ul><li>语法分析与词法分析不同，词法分析是顺序执行，可以使用throw抛出异常，在顶层记录错误并继续执行 </li><li>而语法分析是递归调用的，不能够被中断，因此把错误暂存而不是抛出</li></ul></li><li><p>并且由一遍扫描改为多遍扫描也不能顺序地依次处理错误。因此，修改处理逻辑，将所有错误先暂存并直接处理，最后一起输出。</p></li><li><p>需要注意的是一遍扫描错误抛出的顺序是按行数升序的，但多遍扫描的顺序一次是词法分析错误、语法分析错误、语义分析错误等，需要在输出前按行数排序再输出</p></li></ul><h1 id="5-语义分析设计"><a href="#5-语义分析设计" class="headerlink" title="5 语义分析设计"></a>5 语义分析设计</h1><h2 id="5-1-编码前的设计"><a href="#5-1-编码前的设计" class="headerlink" title="5.1 编码前的设计"></a>5.1 编码前的设计</h2><p>在这一阶段，不需要进行中间代码生成，只需要输出符号表内容。且指导书在中间代码生成这一章写道：</p><blockquote><p>对于符号表的生命周期，可以是遍历 AST 后，生成一张<strong>完整的符号表</strong>，然后再进行代码生成；也可以是在遍历过程中创建<strong>栈式符号表</strong>，随着遍历过程创建和销毁，同时进行代码生成。</p></blockquote><p>因此，暂时设计为先遍历AST生成树形符号表，再在后面的中间代码生成时做增量式开发。</p><hr><p>采用访问者模式：</p><ul><li>设计一个单例<code>Visitor</code>类，其包含不同语法成分的<code>visit()</code>方法，解析语法树并调用下层的<code>visit()</code>方法。</li><li>仅<code>visit(CompUnit compUnit)</code>方法为<code>public</code>以便外层调用，其余语法成分的<code>visit()</code>方法设置为<code>private</code>被其调用。</li></ul><h2 id="5-2-编码后的设计"><a href="#5-2-编码后的设计" class="headerlink" title="5.2 编码后的设计"></a>5.2 编码后的设计</h2><h3 id="5-2-1-符号和符号表的类设计"><a href="#5-2-1-符号和符号表的类设计" class="headerlink" title="5.2.1 符号和符号表的类设计"></a>5.2.1 符号和符号表的类设计</h3><ul><li><p>符号类<code>Symbol</code>设置为抽象类：<code>ConstInt, ConstChar, ConstIntArray, ConstCharArray, ConstInt, ConstChar, ConstIntArray, ConstCharArray</code>这8种符号每种各设置一个子类<code>xxxSymbol</code>继承<code>Symbol</code>；<code>IntFunc, CharFunc, VoidFunc</code>这3种符号设计一个子类<code>FuncSymbol</code>；共9个继承。</p></li><li><p>符号表需要维持树状结构，因此添加<code>fatherTable</code>这一属性。构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SymbolTable</span><span class="params">(SymbolTable fatherTable)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.fatherTable = fatherTable;</span><br><span class="line">    <span class="built_in">this</span>.scopeId = scopeIdCounter++;</span><br><span class="line">    fatherTable.childrenTables.add(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">SymbolTable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.fatherTable = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.scopeId = scopeIdCounter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中根符号表作为静态属性存储以便输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SymbolTable</span> <span class="variable">ROOT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SymbolTable</span>(); <span class="comment">// 根符号表，即全局符号表</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-2-2-访问者设计"><a href="#5-2-2-访问者设计" class="headerlink" title="5.2.2 访问者设计"></a>5.2.2 访问者设计</h3><ul><li>访问者总体结构与 #5.1 编码前的设计相同；</li><li>在访问者中维护一个<code>curSymbolTab</code>属性保存当前的符号表；</li><li>另有其他属性用来辅助语义分析（直接作为Visitor属性就不用在方法中传递参数了）。</li></ul><h3 id="5-2-3-语义分析后的改动"><a href="#5-2-3-语义分析后的改动" class="headerlink" title="5.2.3 语义分析后的改动"></a>5.2.3 语义分析后的改动</h3><ul><li>解耦词法分析器和语法分析器，优化了对外接口</li><li>为语法成分属性添加Getter</li><li>UnaryExp → UnaryOp UnaryExp这条规则不应拆分子类而应把UnaryOp作为UnaryExp的属性</li><li>重构多条规则语法成分：将Stmt、BlockItem、PrimaryExp中的自反属性删去；将UnaryExp中的属性更名为UnaryExpWithoutOp。这样避免了在语义分析时，使用<code>unaryExp.getUnaryExp(), primaryExp.getPrimaryExp(), stmt.getStmt() instanceof ReturnStmt</code>等等冗余且易出错的调用。</li></ul><h3 id="5-2-4-完成后的思考"><a href="#5-2-4-完成后的思考" class="headerlink" title="5.2.4 完成后的思考"></a>5.2.4 完成后的思考</h3><p>相比于语法分析，这次的主要代码均在一个文件下（<code>Visitor.java</code>），耦合度高、模块化差、难以阅读和调试。但由于这次只是部分的语义分析，不涉及中间代码生成，因此期待在后面的迭代中优化结构、解耦合。</p><h1 id="6-代码生成设计"><a href="#6-代码生成设计" class="headerlink" title="6 代码生成设计"></a>6 代码生成设计</h1><h2 id="6-1-编码前的设计"><a href="#6-1-编码前的设计" class="headerlink" title="6.1 编码前的设计"></a>6.1 编码前的设计</h2><h3 id="6-1-1-中间代码生成设计"><a href="#6-1-1-中间代码生成设计" class="headerlink" title="6.1.1 中间代码生成设计"></a>6.1.1 中间代码生成设计</h3><p>按照教程的构建单元设置相关类：</p><img src="https://judge.buaa.edu.cn/cguserImages?_img=30639449344bc202b2e4ac7ba5b5ab1a.png" alt="图片#50% #center" style="zoom: 50%;" /><p>类里均存放初始化的值，仅仅用于转成LLVM IR文本。实际要输出常量的值应差符号表。</p><p>指令：</p><table><thead><tr><th>LLVM IR</th><th>使用方法</th><th>简介</th></tr></thead><tbody><tr><td><code>add</code></td><td><code>&lt;result&gt; = add &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>&#x2F;</td></tr><tr><td><code>sub</code></td><td><code>&lt;result&gt; = sub &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>&#x2F;</td></tr><tr><td><code>mul</code></td><td><code>&lt;result&gt; = mul &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>&#x2F;</td></tr><tr><td><code>sdiv</code></td><td><code>&lt;result&gt; = sdiv &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>有符号除法</td></tr><tr><td><code>srem</code></td><td><code>&lt;result&gt; = srem &lt;baseType&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>有符号取余</td></tr><tr><td><code>icmp</code></td><td><code>&lt;result&gt; = icmp &lt;cond&gt; &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>比较指令</td></tr><tr><td><code>and</code></td><td><code>&lt;result&gt; = and &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>按位与</td></tr><tr><td><code>or</code></td><td><code>&lt;result&gt; = or &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td><td>按位或</td></tr><tr><td><code>call</code></td><td><code>&lt;result&gt; = call [ret attrs] &lt;ty&gt; &lt;name&gt;(&lt;...args&gt;)</code></td><td>函数调用</td></tr><tr><td><code>alloca</code></td><td><code>&lt;result&gt; = alloca &lt;baseType&gt;</code></td><td>分配内存</td></tr><tr><td><code>load</code></td><td><code>&lt;result&gt; = load &lt;ty&gt;, ptr &lt;pointer&gt;</code></td><td>读取内存</td></tr><tr><td><code>store</code></td><td><code>store &lt;ty&gt; &lt;initValue&gt;, ptr &lt;pointer&gt;</code></td><td>写内存</td></tr><tr><td><code>getelementptr</code></td><td><code>&lt;result&gt; = getelementptr &lt;ty&gt;, ptr &lt;ptrval&gt;&#123;, &lt;ty&gt; &lt;idx&gt;&#125;*</code></td><td>计算目标元素的位置（数组部分会单独详细说明）</td></tr><tr><td><code>phi</code></td><td><code>&lt;result&gt; = phi [fast-math-flags] &lt;ty&gt; [&lt;val0&gt;, &lt;label0&gt;], ...</code></td><td>&#x2F;</td></tr><tr><td><code>zext..to</code></td><td><code>&lt;result&gt; = zext &lt;ty&gt; &lt;initValue&gt; to &lt;ty2&gt;</code></td><td>将 <code>ty</code> 的 <code>initValue</code> 的 baseType 扩充为 <code>ty2</code>（zero extend）</td></tr><tr><td><code>trunc..to</code></td><td><code>&lt;result&gt; = trunc &lt;ty&gt; &lt;initValue&gt; to &lt;ty2&gt;</code></td><td>将 <code>ty</code> 的 <code>initValue</code> 的 baseType 缩减为 <code>ty2</code>（truncate）</td></tr><tr><td><code>br</code></td><td><code>br i1 &lt;cond&gt;, label &lt;iftrue&gt;, label &lt;iffalse&gt;</code> <code>br label &lt;dest&gt;</code></td><td>改变控制流</td></tr><tr><td><code>ret</code></td><td><code>ret &lt;baseType&gt; &lt;initValue&gt; </code>, <code>ret void</code></td><td>退出当前函数，并返回值</td></tr></tbody></table><ul><li>在生成对应指令时，将slot加入函数域。例如在<code>visitAddExp</code>中，仅在在生成add指令时将result作为新slot加入函数域，其他slot均在调用的<code>visitMulExp</code>中已加入函数域。</li><li>符号类中新增address字段，存放符号分配到的地址空间</li><li>我们规定数组名只用来（1）函数传参（此时应由FuncRParam一路推导至Ident，不存在任何其他符号），（2）通过索引取数组里面的值。</li></ul><table><thead><tr><th></th><th>全局作用域</th><th>局部作用域</th><th>共性</th></tr></thead><tbody><tr><td><strong>常量</strong></td><td></td><td></td><td>单个常量和常量数组均需给定<code>ConstExp</code>（即可在编译时计算的）初始值</td></tr><tr><td><strong>变量</strong></td><td>若有初始值，则必须是可计算的<code>ConstExp</code>；若无初始值，置零</td><td>可以是不可计算的<code>Exp</code></td><td>可以不带初始值</td></tr><tr><td>共性</td><td>@声明，在顶层，属于<code>GlobalValue</code>；需要保存初始值</td><td>常量和变量jun<code>alloca</code>指令声明，仅保存对应的虚拟寄存器</td><td></td></tr></tbody></table><ul><li><p>一个if语句将当前基本块分为4个基本块（有else）或3个基本块（无else）</p></li><li><p>一个for语句将当前基本块分为5块</p><table><thead><tr><th>B1</th><th>preForStmt（若无preForStmt，则无B1）</th></tr></thead><tbody><tr><td>B2</td><td>Cond，条件跳转指令B3、B5（若无Cond，则是无条件跳转B3）</td></tr><tr><td>B3</td><td>Stmt，无条件跳转B4</td></tr><tr><td>B4</td><td>postStmt，无条件跳转B2 （<strong>continue语句跳点</strong>）</td></tr><tr><td>B5</td><td>（end）（<strong>break语句跳点</strong>）</td></tr></tbody></table></li><li><p>暂时不考虑SSA形式和phi指令，符号表存储地址，每次引用变量使用load，赋值变量使用store。</p></li><li><p>函数传递的非指针参数不能修改，因此<strong>在进入函数时</strong>，需要为其alloca一个地址空间，并将传进的参数赋给它（相当于变量定义）。<strong>不能在第一次使用时再分配并赋值</strong>，因为如果在循环体内使用该变量，则会导致死循环：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun2</span><span class="params">(<span class="type">int</span> a)</span>  <span class="comment">// a=6</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;a &gt;= <span class="number">1</span>;) <span class="comment">// 第一次使用时</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = b * a;</span><br><span class="line">        a = a - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num = num + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a! = %d, num = %d\n&quot;</span>, b, num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">define dso_local i32 @fun2(i32 %0) &#123;</span><br><span class="line">1:</span><br><span class="line">%2 = alloca i32</span><br><span class="line">store i32 1, i32* %2</span><br><span class="line">%3 = alloca i32</span><br><span class="line">store i32 1, i32* %3</span><br><span class="line">br label %4</span><br><span class="line">4:</span><br><span class="line">%5 = icmp sge i32 %0, 1; for循环的cond块。若不分配，这里会始终会用a的旧值；而如果在此分配并赋值，则会一直赋相同的值给a</span><br><span class="line">%6 = zext i1 %5 to i32</span><br><span class="line">%7 = icmp ne i32 %6, 0</span><br><span class="line">br i1 %7, label %8, label %26</span><br></pre></td></tr></table></figure><h3 id="6-1-2-后端代码生成设计"><a href="#6-1-2-后端代码生成设计" class="headerlink" title="6.1.2 后端代码生成设计"></a>6.1.2 后端代码生成设计</h3><ul><li><p>以函数为单位管理栈帧、分配全局寄存器，以基本块为单位分配临时寄存器（寄存器分配实现在文档的优化部分）</p></li><li><p>在LLVM IR中，存在i32和i8两种类型，但是在MIPS中，均使用32位字存储。</p></li><li><p>栈帧结构（简化了部分结构）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 栈帧结构（从高到低增长）：</span><br><span class="line"> * sp+size-&gt;|- - - - - - - |   以下为栈帧内容：</span><br><span class="line"> *          |  局部变量      |</span><br><span class="line"> *          |- - - - - - - |   以下调用函数后需生成的：</span><br><span class="line"> *          |  返回地址      |</span><br><span class="line"> *          |- - - - - - - |</span><br><span class="line"> *          |  （保留寄存器） |   （即全局寄存器s0-s7）</span><br><span class="line"> *          |- - - - - - - |</span><br><span class="line"> *          |  被调用者参数  |   （包括a0-a3。从高到低，先压最后一个参数）</span><br><span class="line"> *  sp-&gt;    |- - - - - - - |</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p><img src="/../assets/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/mips-stackframe.png" alt="mips-stackframe"></p></li><li><p>函数调用设计：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* 【调用者动作】：</span><br><span class="line">*          1. 保存ra寄存器</span><br><span class="line">*          2. 将后续需要用到的保留寄存器值存入栈中</span><br><span class="line">*          3. 将参数压栈、[如果a0-a3有冲突（需要传递且后续要用到），则需要保存并恢复]</span><br><span class="line">*          4. 更改sp寄存器的值</span><br><span class="line">*          5. 使用jal指令</span><br><span class="line">*          6. 取v0返回值并填入相应寄存器（若有返回值）</span><br><span class="line">*          7. 将sp寄存器的值恢复</span><br><span class="line">*          8. 恢复ra寄存器值、保存的寄存器值、恢复冲突的a0-a3寄存器值</span><br><span class="line">*          9. 继续其他指令……</span><br><span class="line">*  【被调用者动作】：</span><br><span class="line">*          1. 执行函数逻辑，若使用参数则取寄存器值或栈上值</span><br><span class="line">*          2. 执行到ret指令，返回值存入v0（若有）</span><br><span class="line">*          3. 使用jr ra返回</span><br></pre></td></tr></table></figure><ul><li>需要注意的是，由于被调用者需要靠偏移取参数，所以在将参数压栈时，应该保证不会出现寄存器溢出的情况，否则会导致偏移与参数不对应。</li></ul></li></ul><h2 id="6-2-编码后的设计"><a href="#6-2-编码后的设计" class="headerlink" title="6.2 编码后的设计"></a>6.2 编码后的设计</h2><ul><li>遵循<strong>里氏替换原则</strong>和<strong>开放封闭原则</strong>，将LLVM IR和MIPS的指令都设置为一个接口或抽象类，并在具体的每条指令中重写对应的输出方法，调用者使用指令类的多态属性完成每条指令的输出。且当需要新增指令时，不需要修改原来的代码，只需要新增类并继承抽象父类或实现接口即可。</li></ul><h1 id="7-代码优化设计"><a href="#7-代码优化设计" class="headerlink" title="7. 代码优化设计"></a>7. 代码优化设计</h1><h2 id="7-1-寄存器分配"><a href="#7-1-寄存器分配" class="headerlink" title="7.1. 寄存器分配"></a>7.1. 寄存器分配</h2><p>在目标代码生成的指导书中：</p><blockquote><p>在 MIPS 这种<strong>寄存器到寄存器</strong>模型中，每个参与运算的值都必须被加载到寄存器中，因此在我们的 IR 中，参与运算的变量都应该对应一个寄存器，在 IR 中，我们将其称为<strong>虚拟寄存器</strong>。虚拟寄存器数目是无限的，但是当翻译为目标平台的汇编代码时，就需要将其映射到一组有限的寄存器中，这个过程就是<strong>寄存器分配</strong>。</p><p>对于规范的寄存器分配，则需要考虑<strong>全局寄存器</strong>和<strong>局部寄存器</strong>的分配，分别对应 MIPS 中的 <code>s</code> 和 <code>t</code> 寄存器。……</p></blockquote><p>因此，<strong>我在生成目标代码时就已经分配了寄存器</strong>（因此优化前和优化后finalCycle差距可能不大）。以下是具体实现思路。</p><h3 id="7-1-1-跨块活跃变量：采用图着色法分配全局寄存器"><a href="#7-1-1-跨块活跃变量：采用图着色法分配全局寄存器" class="headerlink" title="7.1.1 跨块活跃变量：采用图着色法分配全局寄存器"></a>7.1.1 跨块活跃变量：采用图着色法分配全局寄存器</h3><h4 id="7-1-1-1-数据流分析"><a href="#7-1-1-1-数据流分析" class="headerlink" title="7.1.1.1 数据流分析"></a>7.1.1.1 数据流分析</h4><p>在LLVM IR每条具体指令类中添加<code>def</code>和<code>use</code>集，并在构造方法中将对应变量加入这两个集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当有集合的in集发生变化时，继续迭代</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(changed) &#123;</span><br><span class="line">    changed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> basicBlocks.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">BasicBlock</span> <span class="variable">basicBlock</span> <span class="operator">=</span> basicBlocks.get(i);</span><br><span class="line">        <span class="comment">// BasicBlock的liveOut集合为其所有后继的liveIn集合的并集</span></span><br><span class="line">        <span class="keyword">for</span> (BasicBlock succ: basicBlock.succs) &#123;</span><br><span class="line">            basicBlock.liveOut.addAll(succ.liveIn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算每条指令的in集和out集</span></span><br><span class="line">        List&lt;Instruction&gt; instructions = basicBlock.instructions;</span><br><span class="line">        <span class="comment">// BasicBlock的最后一条指令的liveOut集合即为liveOut集合</span></span><br><span class="line">        Set&lt;Slot&gt; succsLiveIn = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(basicBlock.liveOut);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> instructions.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">Instruction</span> <span class="variable">instruction</span> <span class="operator">=</span> instructions.get(j);</span><br><span class="line">            instruction.liveOut = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(succsLiveIn);   <span class="comment">// 每条指令的liveOut集合为其后继的liveIn集合</span></span><br><span class="line">            instruction.liveIn = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(instruction.liveOut);</span><br><span class="line">            instruction.liveIn.removeAll(instruction.def);</span><br><span class="line">            instruction.liveIn.addAll(instruction.use);</span><br><span class="line">            succsLiveIn = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(instruction.liveIn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一条指令的liveIn集合即为BasicBlock的liveIn集合</span></span><br><span class="line">        <span class="keyword">if</span> (!basicBlock.liveIn.equals(succsLiveIn)) &#123;</span><br><span class="line">            changed = <span class="literal">true</span>;</span><br><span class="line">            basicBlock.liveIn = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(succsLiveIn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在对每条指令的<code>liveIn</code>和<code>liveOut</code>集计算的基础上，计算基本块的<code>liveIn</code>和<code>liveOut</code>集。</p><p>需要注意在计算函数的跨块活跃变量时，将所有的<code>liveIn</code>和<code>liveOut</code>集变量加入后，需要删除所有作为函数参数的变量（包括指针型）。<br>这是因为函数参数一概不分配寄存器，因此尽管在参数中出现，也不加入跨块活跃变量集合。</p><h4 id="7-1-1-2-图着色算法"><a href="#7-1-1-2-图着色算法" class="headerlink" title="7.1.1.2 图着色算法"></a>7.1.1.2 图着色算法</h4><p>为了简便，我在实现中对冲突的定义是：活跃范围重合。因此，在数据流分析后，同时出现在<code>liveIn</code>或<code>liveOut</code>集合的、以及在块内活跃范围冲突的变量视为冲突。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造冲突图</span></span><br><span class="line"><span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(); <span class="comment">// 用于移除节点得到队列</span></span><br><span class="line"><span class="type">Graph</span> <span class="variable">conflict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(); <span class="comment">// 副本，用于保存冲突图</span></span><br><span class="line"><span class="keyword">for</span> (Slot node: function.interBlockLive) &#123;</span><br><span class="line">    graph.addNode(node);</span><br><span class="line">    conflict.addNode(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在liveIn和liveOut中同时出现的变量，即为冲突变量，添加边</span></span><br><span class="line"><span class="keyword">for</span> (BasicBlock block: function.basicBlocks) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Slot slot1: block.liveIn) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Slot slot2: block.liveIn) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slot1 != slot2 &amp;&amp;</span><br><span class="line">                function.interBlockLive.contains(slot1) &amp;&amp;</span><br><span class="line">                function.interBlockLive.contains(slot2)) &#123;</span><br><span class="line">                graph.addEdge(slot1, slot2);</span><br><span class="line">                conflict.addEdge(slot1, slot2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Slot slot1: block.liveOut) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Slot slot2: block.liveOut) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slot1 != slot2 &amp;&amp;</span><br><span class="line">                function.interBlockLive.contains(slot1) &amp;&amp;</span><br><span class="line">                function.interBlockLive.contains(slot2)) &#123;</span><br><span class="line">                graph.addEdge(slot1, slot2);</span><br><span class="line">                conflict.addEdge(slot1, slot2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对每个基本块，检查只出现在 in 或 out 中的变量，若活性范围冲突则也添加冲突边</span></span><br><span class="line"><span class="keyword">for</span> (BasicBlock block: function.basicBlocks) &#123;</span><br><span class="line">    Set&lt;Slot&gt; intersection = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(block.liveIn);   <span class="comment">// 交集</span></span><br><span class="line">    intersection.retainAll(block.liveOut);</span><br><span class="line"></span><br><span class="line">    Set&lt;Slot&gt; liveInRemoveInter = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(block.liveIn);</span><br><span class="line">    liveInRemoveInter.removeAll(intersection);</span><br><span class="line">    Set&lt;Slot&gt; liveOutRemoveInter = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(block.liveOut);</span><br><span class="line">    liveOutRemoveInter.removeAll(intersection);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Slot slot1: liveInRemoveInter) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Slot slot2: liveOutRemoveInter) &#123;</span><br><span class="line">            <span class="keyword">if</span> (function.interBlockLive.contains(slot1) &amp;&amp;</span><br><span class="line">                    function.interBlockLive.contains(slot2)) &#123;</span><br><span class="line">                <span class="comment">// 滤去函数参数等不跨块活跃的变量</span></span><br><span class="line">                <span class="type">Instruction</span> <span class="variable">defInst</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (Instruction inst: block.instructions) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (inst.def.contains(slot2)) &#123;</span><br><span class="line">                        <span class="comment">// slot2只出现在liveOut中，则有一条定义它的指令</span></span><br><span class="line">                        defInst = inst;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 定义后，slot1仍活跃，即为冲突</span></span><br><span class="line">                <span class="keyword">if</span> (defInst.liveOut.contains(slot1)) &#123;</span><br><span class="line">                    graph.addEdge(slot1, slot2);</span><br><span class="line">                    conflict.addEdge(slot1, slot2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中保存冲突图的副本是为了在后续移走节点也能查询到每个变量的冲突情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Slot&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 执行图着色算法</span></span><br><span class="line"><span class="keyword">while</span> (graph.getNodesNum() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">canRemove</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 【为保证移出顺序，先对邻接表排序】</span></span><br><span class="line">    List&lt;Map.Entry&lt;Slot, Set&lt;Slot&gt;&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(graph.adjacencyList.entrySet());</span><br><span class="line">    list.sort(Comparator.comparingInt(o -&gt; o.getKey().slotId));</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Slot, Set&lt;Slot&gt;&gt; entry : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph.getDegree(entry.getKey()) &lt; RegisterPool.savedRegisters.size()) &#123;</span><br><span class="line">            queue.addLast(entry.getKey());</span><br><span class="line">            graph.removeNode(entry.getKey());</span><br><span class="line">            canRemove = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;remove &quot;</span> + entry.getKey().toText());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!canRemove) &#123;</span><br><span class="line">        <span class="comment">// 若无法删除节点，即图中存在度数大于等于寄存器数量的节点，保存在栈上</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 优化时，选择引用次数最少的节点进行合并</span></span><br><span class="line">        <span class="type">Slot</span> <span class="variable">remove</span> <span class="operator">=</span> list.get(<span class="number">0</span>).getKey();</span><br><span class="line">        graph.removeNode(remove);</span><br><span class="line">        conflict.removeNode(remove);    <span class="comment">// 【不分配，移出冲突图】</span></span><br><span class="line">        System.out.println(<span class="string">&quot;spill &quot;</span> + remove.toText());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照结点移走的反向顺序将点和边添加回去，并分配颜色</span></span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    <span class="type">Slot</span> <span class="variable">slot</span> <span class="operator">=</span> queue.removeLast();</span><br><span class="line">    graph.addNode(slot);</span><br><span class="line">    List&lt;Register&gt; available = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(RegisterPool.savedRegisters);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Slot, Set&lt;Slot&gt;&gt; entry: graph.adjacencyList.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (conflict.adjacencyList.get(slot).contains(entry.getKey())) &#123;</span><br><span class="line">            <span class="comment">// 若已在图中的节点与此节点存在冲突</span></span><br><span class="line">            available.remove(registerPool.globalAllocation.get(entry.getKey()));</span><br><span class="line">            graph.addEdge(slot, entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 挑选一个可用的寄存器着色</span></span><br><span class="line">    <span class="keyword">assert</span> !available.isEmpty();</span><br><span class="line">    registerPool.globalAllocation.put(slot, available.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对于选择哪个节点移除暂时没有实现选择算法，后续可能优化为引用次数最少的不分配全局寄存器。</p><p>需要注意由于<code>HashMap</code>遍历顺序的不确定性，需要先将其排序再进行后续操作。</p><h3 id="7-1-2-不跨块活跃的变量：采用寄存器池分配临时寄存器"><a href="#7-1-2-不跨块活跃的变量：采用寄存器池分配临时寄存器" class="headerlink" title="7.1.2 不跨块活跃的变量：采用寄存器池分配临时寄存器"></a>7.1.2 不跨块活跃的变量：采用寄存器池分配临时寄存器</h3><p>在后端实现了一个<code>RegisterPool.java</code>类，虽然全局寄存器不使用寄存器池分配，但是实现这个类可以便于对变量对应的寄存器统一管理。生成目标代码时，可以统一使用提供的接口找到对应的寄存器。</p><p>总的来说，我实现的临时寄存器池使用<strong>FIFO算法</strong>，维护一个<code>allocated</code>表和<code>tempQueue</code>，前者存储变量对应的寄存器，后者是一个记录分配顺序的队列。当新增变量时，从寄存器池中分配一个变量，并添加<code>allocated</code>表项、加入<code>tempQueue</code>队尾；当释放寄存器时，移除<code>allocated</code>表项以及<code>tempQueue</code>对应寄存器；当寄存器不够需要溢出时，取<code>tempQueue</code>的队首溢出到内存并分配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配临时寄存器并与Slot【绑定】</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> slot 需要分配的slot</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> curStackFrame 当前的栈帧</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 分配的寄存器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Register <span class="title function_">bindAllocTemp</span><span class="params">(Slot slot, StackFrame curStackFrame)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是跨块活跃变量，分配保留寄存器，否则分配临时寄存器</span></span><br><span class="line">    <span class="keyword">for</span> (Register r: tempRegisters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!allocated.containsValue(r)) &#123;</span><br><span class="line">            <span class="comment">// 若空闲，即找到</span></span><br><span class="line">            tempQueue.addLast(r);</span><br><span class="line">            allocated.put(slot, r);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 溢出处理</span></span><br><span class="line">    <span class="keyword">return</span> spill(slot, curStackFrame);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 溢出处理，将溢出寄存器的值存到栈上</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> curStackFrame 当前的栈帧</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> slot 需要分配的slot，可为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Register <span class="title function_">spill</span><span class="params">(Slot slot, StackFrame curStackFrame)</span> &#123;</span><br><span class="line">    <span class="comment">// FIFO算法，取出最早分配的寄存器</span></span><br><span class="line">    <span class="type">Register</span> <span class="variable">spillRegister</span> <span class="operator">=</span> tempQueue.removeFirst();</span><br><span class="line">    <span class="type">Slot</span> <span class="variable">spillSlot</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Slot, Register&gt; entry: allocated.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() == spillRegister) &#123;</span><br><span class="line">            spillSlot = entry.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将寄存器的值存到栈上</span></span><br><span class="line">    curStackFrame.recordLocal(spillSlot, <span class="number">4</span>);</span><br><span class="line">    mipsCode.addMIPSInst(<span class="keyword">new</span> <span class="title class_">SW</span>(spillRegister, Register.SP, -curStackFrame.getSize()).setComment(<span class="string">&quot;\tspill reg of &quot;</span> + spillSlot.toText()));</span><br><span class="line">    <span class="comment">// 移除allocated中的记录</span></span><br><span class="line">    allocated.remove(spillSlot);</span><br><span class="line">    <span class="keyword">if</span> (slot != <span class="literal">null</span>) &#123;</span><br><span class="line">        tempQueue.addLast(spillRegister);</span><br><span class="line">        allocated.put(slot, spillRegister);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> spillRegister;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，每条指令的翻译步骤即：</p><blockquote><ol><li>使用 find 获取 use 的寄存器</li><li>使用 deallocUse 回收 use 中不活跃变量的寄存器</li><li>使用 allocDef 分配 def 使用的寄存器【allocDef可能返回null，此时需要保存到栈上】</li><li>使用 allocTemp 分配不绑定slot的寄存器</li><li>生成MIPS指令</li></ol></blockquote><p>这些步骤不能随意调换顺序。具体来说：</p><ul><li>先<code>find</code>再<code>deallocUse</code>（否则找不到就释放了）</li><li>先<code>deallocUse</code>再<code>allocDef</code>（这样可以立即使用use不再使用的寄存器，例如addiu $t0, $t0, -4这种指令）</li><li>先<code>allocDef</code>再<code>allocTemp</code>。（否则，因为后者不绑定Slot，会分配到一样的寄存器而出错）</li></ul><blockquote><p>此优化与MIPS生成一起完成，因此提交的优化前目标代码与此一致。</p></blockquote><h2 id="7-2-基本块合并"><a href="#7-2-基本块合并" class="headerlink" title="7.2. 基本块合并"></a>7.2. 基本块合并</h2><p>例如，在公开testcase7中，生成了如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">101:                          ; preds = 96</span><br><span class="line">    %102 = load i32, i32* %1      ;load value of i</span><br><span class="line">    %103 = getelementptr [10 x i32], [10 x i32]* @a, i32 0, i32 %102      ;get &amp;a[%102]</span><br><span class="line">    %104 = load i32, i32* %103    ;load value of a[%102]</span><br><span class="line">    call void @putint(i32 %104)</span><br><span class="line">    call void @putstr(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.0, i64 0, i64 0))</span><br><span class="line">    %105 = load i32, i32* %1      ;load value of i</span><br><span class="line">    %106 = add i32 %105, 1</span><br><span class="line">    store i32 %106, i32* %1</span><br><span class="line">    br label %107</span><br><span class="line">107:                          ; preds = 101</span><br><span class="line">    br label %96</span><br><span class="line">108: ; preds = 96</span><br></pre></td></tr></table></figure><p>经过基本块合并优化后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">101:                          ; preds = 96</span><br><span class="line">    %102 = load i32, i32* %1      ;load value of i</span><br><span class="line">    %103 = getelementptr [10 x i32], [10 x i32]* @a, i32 0, i32 %102      ;get &amp;a[%102]</span><br><span class="line">    %104 = load i32, i32* %103    ;load value of a[%102]</span><br><span class="line">    call void @putint(i32 %104)</span><br><span class="line">    call void @putstr(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.0, i64 0, i64 0))</span><br><span class="line">    %105 = load i32, i32* %1      ;load value of i</span><br><span class="line">    %106 = add i32 %105, 1</span><br><span class="line">    store i32 %106, i32* %1</span><br><span class="line">    br label %96</span><br><span class="line">107:                          ; preds = 96</span><br></pre></td></tr></table></figure><h2 id="7-3-乘除法优化"><a href="#7-3-乘除法优化" class="headerlink" title="7.3. 乘除法优化"></a>7.3. 乘除法优化</h2><p>只针对第二个操作数为立即数的乘除指令进行优化。</p><h3 id="7-3-1-乘法优化"><a href="#7-3-1-乘法优化" class="headerlink" title="7.3.1 乘法优化"></a>7.3.1 乘法优化</h3><p>对于乘数为0、1、2的整数幂、2的整数幂的相反数、2的整数幂-1、2的整数幂-2、2的整数幂+1进行优化，转为若干移位指令和加减指令。</p><h3 id="7-3-2-除法优化"><a href="#7-3-2-除法优化" class="headerlink" title="7.3.2 除法优化"></a>7.3.2 除法优化</h3><p>对于除数为2的整数幂、2的整数幂的相反数进行优化。</p><p>此外，对于能转化为乘法和移位运算的进行优化，例如对于testcase7中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div $t0, $t0, 5</span><br></pre></td></tr></table></figure><p>被优化为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    slt $t1, $zero, $t0</span><br><span class="line">    bnez $t1, _L_divOptimize_0</span><br><span class="line">    subu $t0, $zero, $t0</span><br><span class="line">_L_divOptimize_0:</span><br><span class="line">    li $t2, 3435973837</span><br><span class="line">    multu $t0, $t2</span><br><span class="line">    mfhi $t0</span><br><span class="line">    sra $t0, $t0, 2</span><br><span class="line">    bnez $t1, _L_divOptimize_1</span><br><span class="line">    subu $t0, $zero, $t0</span><br><span class="line">_L_divOptimize_1:</span><br></pre></td></tr></table></figure><p>需要注意，优化时，需要分正负两种情况，不然会产生错误。</p><h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><p>由于生成MIPS时直接完成寄存器分配这一“优化任务”，因此耗费了许多时间。最后因时间紧迫，其他优化暂时没有完成。</p><blockquote><p>Author：bush</p><p>更新日志：</p><ul><li>2024.9.24：完成词法分析，完成文档#1、#2、#3</li><li>2024.10.14：完成语法分析及此部分文档#4，修改#2.2，新增#3.2.3</li><li>2024.10.19：在期中模拟考发现回溯时未回溯已抛出错误导致多输出错误，修改#4.2.5</li><li>2024.11.2：完成语义分析，完成文档#5</li><li>2024.12.12：完成MIPS代码生成，完成文档#6</li><li>2024.12.17：完成优化文档#7</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编译技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
